\documentclass[12pt]{article} 

\usepackage{titling}
\usepackage{extsizes} 
\usepackage{tikz} % Move this line to the preamble
\usepackage{listings} % Move this line to the preamble
\usepackage[utf8]{inputenc} % Ensure UTF-8 encoding
\usepackage{textcomp} % Provides \textendash



\pretitle{\vspace*{2in}\begin{center}\LARGE\bfseries} % Adjust vertical space before title
\posttitle{\par\end{center}\vskip 0.5em}
\preauthor{\begin{center}\large}
\postauthor{\end{center}}

\newcommand{\subtitle}[1]{%
    \posttitle{%
        \par\end{center}
        \begin{center}\Large#1\end{center}
        \vskip 0.5em}%
}
\title{Projeto de Compiladores 2024/25}
\subtitle{Compilador para a linguagem deiGO}
\author{Trabalho realizado por:\\
Miguel Castela uc2022212972 \\
Nuno Batista uc2022212972}

\date{}
\begin{document}

\maketitle

\newpage

\section{Introduction}
Este relatório descreve o desenvolvimento de um compilador para a linguagem deiGO, realizado no âmbito do projeto da disciplina de Compiladores do ano letivo 2024/25. O objetivo deste projeto é aplicar os conhecimentos adquiridos ao longo do curso na construção de um compilador funcional.

\section{Grammar}
    Our implementation focuses on resolving ambiguities by explicitly defining operator precedence and associativity rules.\\ Non-termials where simplified by introducing auxiliary nodes to handle the optional elements and repititions.
    \begin{itemize}
        \item \textbf{Handling of Optional and Repeated Elements}: \\ Optional and repeated elements are handled using specific grammar rules that provide alternatives for their presence or absence.
            By defining optional elements explicitly, we also ensure that the parser can handle cases where certain elements are missing. This is crucial for maintaining the correctness of the AST later on.
            By using optional nodes, we can easily append new declarations to the existing list.
            \begin{center}
                \begin{lstlisting}[language=C, caption={StarCommaId Rule}, basicstyle=\small\ttfamily]
StarCommaId:StarCommaId COMMA IDENTIFIER
    {
        $$ = $1;
        struct node *new_decl = new_node(VarDecl, NULL);
        add_child(new_decl, new_node(Identifier, $3));
        add_child($$, new_decl);
    
    // The type is added in the VarSpec rule
    }
    |   
    {   
        $$ = new_node(AUX, NULL);
    };
                \end{lstlisting}
            \end{center}

            This rule, designed to manage repeated identifiers separated by commas, is particularly useful for handling multiple variable declarations in a single statement. For this, the rule employs recursion, where each node represents a variable declaration.   
            \begin{itemize}
                \item \textbf{Recursive case}:  When an identifier is followed by a comma and another identifier, the existing node (StarCommaId) serves as the "parent" or "father" node. A new VarDecl node is created for the subsequent identifier, with the identifier as its "child" or "son." This new VarDecl node is then added as a "child" to the parent node (StarCommaId).
                \item \textbf{Base case}:If no preceding identifiers exist, a new AUX node is created to serve as the root or starting "father" node for the list of identifiers.
            \end{itemize}
            By organizing the identifiers with this structure, the rule facilitates the processing and representation of variable declarations as a tree,
        \item \textbf{Optimization and Readibility }: \\ Our grammar rules are desgined to be clear and readable, making it easier to understand the parsing process. We define operator precedence and associativity explicitly to resolve ambiguities. This ensures that expressioons are parsed correctly according to the deiGO language specifications.
            \\Examples of the transcription of the initnal grammar in EBNF notation to the Bison format:
            \begin{center}
                \small\textbf{Declarations \textendash{} VarDeclaration SEMICOLON | FuncDeclaration SEMICOLON}
            \end{center}
            \begin{center}
                \begin{lstlisting}[language=C, basicstyle=\small\ttfamily]
Declarations : Declarations FuncDecl SEMICOLON
    {
        $$ = $1;
        add_child($$, $2);
    }              
    | Declarations VarDecl SEMICOLON
    {
        $$ = $1;
        struct node *var_declarations = new_node(AUX, NULL);
        add_child($$, var_declarations);
        add_child(var_declarations, $2);
    }
    | 
    {
        $$ = new_node(AUX, NULL);
    }
    ;
            \end{lstlisting}
                \end{center}
            \begin{center}
                \small\textbf{VarSpec \textendash{} IDENTIFIER {COMMA IDENTIFIER} Type}
            \end{center}
            \begin{center}
                \begin{lstlisting}[language=C, basicstyle=\small\ttfamily]
VarSpec : IDENTIFIER StarCommaId Type
    {
    $$ = new_node(AUX, NULL);
    struct node *new_decl = new_node(VarDecl, NULL);
    add_child(new_decl, $3);
    add_child(new_decl, new_node(Identifier, $1));
    add_child($$, new_decl);
    add_child($$, $2);
    }
    ;
            \end{lstlisting}
        \end{center}
        \begin{center}
        \small\textbf{FuncDeclaration \textendash{} FUNC IDENTIFIER LPAR [Parameters] RPAR [Type] FuncBody}
        \end{center}
        \begin{center}
        \begin{lstlisting}[language=C, basicstyle=\small\ttfamily]
FuncDecl : FUNC IDENTIFIER LPAR OptFuncParams RPAR OptType FuncBody
{
    $$ = new_node(FuncDecl, NULL);
    struct node *new_func_header = new_node(FuncHeader, NULL);
    add_child($$, new_func_header);
    add_child(new_func_header, new_node(Identifier, $2));
    add_child(new_func_header, $4);
    add_child(new_func_header, $6);
    add_child($$, $7);
}
;
    \end{lstlisting}
    \end{center}
    \end{itemize}


\section{AST/Symbol Table Algorithms and Data Structures}
    \begin{itemize}
        \item \textbf{Auxiliary AST nodes}: \\In our grammar, we use auxiliary(AUX) nodes to store the children of nodes with an undefined number of children. This approach helps in managing optional and repeated elements by acting as a container for multiple instances of a particular non-terminal. This function has the main goal of maintaining a clear and organized AST. By grouping related nodes under an AUX node, we can ensure that the tree structure is easy to traverse and understand. As this is a temporary container at the end of the syntax analasys we perform as DFS transversal to append the AUX nodes children to their respective parent nodes, using que RemoveAux function.EXMPLO (varSpec(?))
    \begin{center}
        \begin{tikzpicture}
            \node[draw, circle] (A) at (3,0) {FuncParams};
            \node[draw, circle] (B) at (0,-3) {AUX};
            \node[draw, circle] (C) at (-2,-5) {AUX};
            \node[draw, circle] (D) at (2,-5) {C1};
            \node[draw, circle] (E) at (0,-7) {C2};
            \node[draw, circle] (F) at (-4,-7) {AUX};
        
            \draw (A) -- (B);
            \draw (B) -- (C);
            \draw (B) -- (D);
            \draw (C) -- (E);
            \draw (C) -- (F);
        \end{tikzpicture}
    \end{center}
        
    
    \item \textbf{Locates}: \\ This macro serves as a way to store the lines and columns of a specific node. In this way we can identify the nodes that are creating a semantic error.
    \item \textbf{AST Structs}: \\ Firstly the node struct:

        \begin{center}
            \begin{lstlisting}[language=C, basicstyle=\small\ttfamily]
struct node {
    enum category category;  
    char *token;
    int token_line, token_column; 
    enum type type;
    char *parameter_list;
     struct node_list *children;
    };
        \end{lstlisting}
    \end{center}
        \begin{table}[h!]
            \centering
            \begin{tabular}{|c|p{10cm}|}
            \hline
            Parameter & \multicolumn{1}{|c|}{Description} \\
            \hline
            category & An enum representing the category of the node. \\
            \hline
            token & A string representing the lexical token associated with the node. \\
            \hline
            token\_line and token\_column & Integers storing the line and column numbers of the token, useful for error reporting. \\
            \hline
            type & An enum representing the type of the node. \\
            \hline
            parameter\_list & A string representing the list of parameters for function nodes. \\
            \hline
            children & A pointer to a \textbf{node\_list struct}, representing the children of this node. \\
            \hline
            \end{tabular}
            \caption{Description of the node struct fields}
            \label{tab:node_struct}
        \end{table}
        \begin{center}
            \begin{lstlisting}[language=C, basicstyle=\small\ttfamily]
struct node_list {
    struct node *node;
    struct node_list *next;
};
        \end{lstlisting}
    \end{center}
This struct is used to store a list of children nodes, where each node is linked to the next node in the list.
 
    \item \textbf{Symbol Table Structs}: \\  
    \begin{center}
        \begin{lstlisting}[language=C, basicstyle=\small\ttfamily]
            struct symbol_list {
    char *identifier;
    enum type type;
    struct node *node;
    int is_parameter;
    struct symbol_list *next;
    int was_used;
    int is_function;
    char *function_parameters;
};

            \end{lstlisting}
        \end{center}
        \begin{table}[h!]
    \centering
    \begin{tabular}{|c|p{10cm}|}
    \hline
    Parameter & \multicolumn{1}{|c|}{Description} \\
    \hline
    identifier & A string representing the name of the symbol. \\
    \hline
    type & An enum representing the type of the symbol. \\
    \hline
    node & A pointer to the AST node associated with the symbol. \\
    \hline
    is\_parameter & An integer indicating if the symbol is a function parameter. \\
    \hline
    next & A pointer to the next symbol\_list element. \\
    \hline
    was\_used & An integer indicating if the symbol was used. \\
    \hline
    is\_function & An integer indicating if the symbol is a function. \\
    \hline
    function\_parameters & A string representing the parameter types of the function. \\
    \hline
    \end{tabular}
    \caption{Description of the symbol struct fields}
    \label{tab:symbol_struct}
\end{table}

    \begin{center}
            \begin{lstlisting}[language=C, basicstyle=\small\ttfamily]
        struct scopes_queue {
            struct symbol_list *table;
            struct scopes_queue *next;
            struct node *func_body; // The function body node is stored here so it can be processed after the function declarations
            char *identifier;
        };        
            \end{lstlisting}
        \end{center}
        This struct stores a queue of symbol tables for managing program scopes. Each scope includes a symbol table, a pointer to the next scope, a pointer to the function body, and the function's identifier.


    \item \textbf{Table Symbols}: \\
    \item \textbf{node children}: \\
    \item \textbf{Syntax Error Handling}:

\end{itemize}



\section{Geração de Código}

\end{document}