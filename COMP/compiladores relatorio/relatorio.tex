\documentclass[12pt]{article} 

\usepackage{titling}
\usepackage{extsizes} 

\pretitle{\vspace*{2in}\begin{center}\LARGE\bfseries} % Adjust vertical space before title
\posttitle{\par\end{center}\vskip 0.5em}
\preauthor{\begin{center}\large}
\postauthor{\end{center}}

\newcommand{\subtitle}[1]{%
    \posttitle{%
        \par\end{center}
        \begin{center}\Large#1\end{center}
        \vskip 0.5em}%
}
\title{Projeto de Compiladores 2024/25}
\subtitle{Compilador para a linguagem deiGO}
\author{Trabalho realizado por:\\
Miguel Castela uc2022212972 \\
Nuno Batista uc2022212972}

\date{}
\begin{document}

\maketitle

\newpage

\section{Introdução}
Este relatório descreve o desenvolvimento de um compilador para a linguagem deiGO, realizado no âmbito do projeto da disciplina de Compiladores do ano letivo 2024/25. O objetivo deste projeto é aplicar os conhecimentos adquiridos ao longo do curso na construção de um compilador funcional.

\section{Gramática}
Our implementation focuses on resolving ambiguities by explicitly defining operator precedence and associativity rules.\\ Non-termials where simplified by introducing auxiliary nodes to handle the optional elements and repititions.
\begin{itemize}
    \item \textbf{Handling of Optional and Repeated Elements}: \\ With the help of AUX nodes, optional and repeated elements are handled using specific grammar rules that provide alternatives for their presence or absences. For example,
    OptFuncParams can either be a FuncParams node or an AUX node representing the absence of function parameters. By defining optional elements explicitly, we also ensure that the parser can handle cases where certain elements are missing. This is crucial for maintaining the correctness of the AST. (For instance, the Declarations rule manages multiple functions and variable declarations). By using AUX and optional nodes, we can easily append new declarations to the existing list, ensuring that the AST remains well structured and easy to transverse.
    \item \textbf{Optimization and Readibility }: \\ Our grammar rules are desgined to be clear and readable, making it easier to understand the parsing process. We define operator precedence and associativity explicitly to resolve ambiguities. This ensures that expressioons are parsed correctly according to the DeiGO language specifications. Additionally, meaningful names for non-terminals and auxiliary nodes are used to enhance the readability of the grammar of the grammar.
    \item \textbf{Syntax Error Handling}: 
\end{itemize}


\section{Algoritmos e estruturas de dados da AST e da tabela de simbolos}
\begin{itemize}
    \item \textbf{Auxiliary AST nodes}: \\In our grammar, we use auxiliary(AUX) nodes to store the children of nodes with an undefined number of children. This approach helps in managing optional elements and repetitions more effectively. These nodes help in managing repeated elements by acting as a container for multiple instances of a particular non-terminal. For example, in the VarSpec rule we use an AUX node to handle mutiple vairable declarations. This function has the main goal of maintaining a clear and organized AST. By grouping related nodes under an AUX node, we can ensure that the tree structure is easy to traverse and understand. As this is a temporary container at the end of the syntax anaasys we perform as DFS transversal to append the AUX nodes children to their respective parent nodes.
\end{itemize}

\section{Algoritmos e Estruturas de Dados}
O compilador desenvolvido é composto por várias fases, cadaaaaa uma responsável por uma parte específica do processo de compilação. As principais fases são:

\begin{itemize}
    \item Análise Léxica
    \item Análise Sintática
    \item Análise Semântica
    \item Geração de Código Intermediário
    \item Otimização
    \item Geração de Código Final
\end{itemize}

\section{Geração de Código}


\end{document}